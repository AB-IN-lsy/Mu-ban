{
	"map": {
		"prefix": "map",
		"body": [
			"map(int, input().split())"
		],
		"description": "map"
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"son = [[0] * 26 for _ in range(N)] ",
			"cnt, idx = [0] * N, 0",
			"",
			"def insert(s):",
			"    global idx",
			"    p = 0 ",
			"    for i in range(len(s)):",
			"        u = ord(s[i]) - ord('a') ",
			"        if not son[p][u]: ",
			"            idx += 1",
			"            son[p][u] = idx ",
			"        p = son[p][u] ",
			"    cnt[p] += 1 ",
			"",
			"def query(s):",
			"    p = 0",
			"    for i in range(len(s)):",
			"        u = ord(s[i]) - ord('a')",
			"        if not son[p][u]: ",
			"            return 0",
			"        p = son[p][u]",
			"    return cnt[p]"
		],
		"description": "Trie"
	},
	"spfa": {
		"prefix": "spfa",
		"body": [
			"from collections import deque",
			"",
			"N = int(1e5 + 10)",
			"INF = int(2e9)",
			"st, dist = [0] * N, [INF] * N",
			"g = [[] for _ in range(N)]",
			"q = deque()",
			"",
			"",
			"def spfa(s):",
			"    dist[s] = 0",
			"    q.appendleft(s)",
			"    st[s] = 1",
			"    while q:",
			"        u = q.pop()",
			"        st[u] = 0",
			"        for v, w in g[u]:",
			"            if dist[v] > dist[u] + w:",
			"                dist[v] = dist[u] + w",
			"                if st[v] == 0:",
			"                    q.appendleft(v)",
			"                    st[v] = 1",
			"    return dist[n]"
		],
		"description": "spfa"
	},
	"二分图匹配": {
		"prefix": "Erfen_graph_match",
		"body": [
			"match, st = [0] * N, [0] * N  ",
			"g = [[] for _ in range(N)]",
			"",
			"",
			"def find(u):",
			"    for v in g[u]:",
			"        if st[v] == 0:",
			"            st[v] = 1",
			"            if match[v] == 0 or find(match[v]): ",
			"                match[v] = u",
			"                return True",
			"    return False",
			""
		],
		"description": "Erfen_graph_match"
	},
	"中国剩余定理": {
		"prefix": "Chinese",
		"body": [
			"def exgcd(a, b):",
			"    global k1, k2",
			"    if b == 0:",
			"        k1, k2 = 1, 0",
			"        return a",
			"    d = exgcd(b, a % b)",
			"    k1, k2 = k2, k1",
			"    k2 -= (a // b) * k1",
			"    return d",
			"",
			"#求一个最小的非负整数 x，满足 ∀i∈[1,n],x≡ai(mod mi)。",
			"n = int(input())",
			"",
			"a1, m1 = map(int, input().split())",
			"flag = 0",
			"for i in range(n - 1):",
			"    a2, m2 = map(int, input().split())",
			"    k1, k2 = 0, 0",
			"    d = exgcd(m1, m2)",
			"    if (a2 - a1) % d:",
			"        flag = 1",
			"        break",
			"    k1 *= (a2 - a1) // d",
			"    # k1' = k1 + k * (m2 // d) , k取任意整数",
			"    t = m2 // d",
			"    k1 = k1 % t  # 取最小的k1",
			"    # x = a + km",
			"    a1 = k1 * m1 + a1",
			"    m1 = m1 // d * m2",
			"",
			"if flag:",
			"    print(-1)",
			"else:",
			"    print(a1 % m1)  #x的最小正整数解"
		],
		"description": "Chinese_remainder_theorem"
	},
	"单调栈": {
		"prefix": "Stack",
		"body": [
			"stk = []",
			"    for num in nums:",
			"        while stk and stk[-1] >= num: #改成 <= 就是求每个数左边第一个比它 大 的数",
			"            stk.pop()",
			"        print(stk[-1] if stk else -1, end=\" \")",
			"        stk.append(num)"
		],
		"description": "单调栈"
	},
	"线段树加法": {
		"prefix": "segment_tree_sum",
		"body": [
			"",
			"ls = lambda p: p << 1",
			"rs = lambda p: p << 1 | 1",
			"",
			"",
			"class Node(object):",
			"    def __init__(self, l, r) -> None:",
			"        self.l = l",
			"        self.r = r",
			"        self.len = 0",
			"        self.tag = 0",
			"",
			"",
			"N = int(1010)",
			"tr = [Node(0, 0) for _ in range(N << 3)]",
			"",
			"",
			"def pushup(p):",
			"    tr[p].len = tr[ls(p)].len + tr[rs(p)].len",
			"",
			"",
			"def build(p, l, r):",
			"    tr[p] = Node(l, r)",
			"    if l == r:",
			"        return",
			"    mid = l + r >> 1",
			"    build(ls(p), l, mid)",
			"    build(rs(p), mid + 1, r)",
			"    pushup(p)",
			"",
			"",
			"def addtag(p, d):",
			"    tr[p].tag += d",
			"    tr[p].len += d * (tr[p].r - tr[p].l + 1)",
			"",
			"",
			"def pushdown(p):",
			"    if tr[p].tag:",
			"        addtag(ls(p), tr[p].tag)",
			"        addtag(rs(p), tr[p].tag)",
			"        tr[p].tag = 0",
			"",
			"",
			"#l, r 是固定的，二分的永远是tr[p].l和tr[p].r",
			"def update(p, l, r, d):",
			"    if l <= tr[p].l and tr[p].r <= r:",
			"        addtag(p, d)",
			"        return",
			"    pushdown(p)",
			"    mid = tr[p].l + tr[p].r >> 1",
			"    if l <= mid:",
			"        update(ls(p), l, r, d)",
			"    if mid < r:",
			"        update(rs(p), l, r, d)",
			"    pushup(p)",
			"",
			"",
			"def query(p, l, r):",
			"    res = 0",
			"    if l <= tr[p].l and tr[p].r <= r:",
			"        return tr[p].len",
			"    pushdown(p)",
			"    mid = tr[p].l + tr[p].r >> 1",
			"    if l <= mid:",
			"        res += query(ls(p), l, r)",
			"    if r > mid:",
			"        res += query(rs(p), l, r)",
			"    return res",
			""
		],
		"description": "线段树"
	},
	"线段树最大值": {
		"prefix": "segment_tree_max",
		"body": [
			"ls = lambda x: x << 1",
			"rs = lambda x: x << 1 | 1",
			"",
			"INF = int(2e9)",
			"",
			"",
			"class Node(object):",
			"    def __init__(self, l, r):",
			"        self.l = l",
			"        self.r = r",
			"        self.x = -INF",
			"",
			"",
			"N = int(2e5 + 10)",
			"tr = [Node(0, 0) for _ in range(N << 2)]",
			"",
			"",
			"def pushup(p):",
			"    tr[p].x = max(tr[ls(p)].x, tr[rs(p)].x)",
			"",
			"",
			"def build(p, l, r):",
			"    tr[p] = Node(l, r)",
			"    if l == r:",
			"        return",
			"    mid = l + r >> 1",
			"    build(ls(p), l, mid)",
			"    build(rs(p), mid + 1, r)",
			"",
			"",
			"def update(p, k, v): #单点修改",
			"    if tr[p].l == k and tr[p].r == k:",
			"        tr[p].x = v",
			"        return",
			"    mid = tr[p].l + tr[p].r >> 1",
			"    if k <= mid:",
			"        update(ls(p), k, v)",
			"    if k > mid:",
			"        update(rs(p), k, v)",
			"    pushup(p)",
			"",
			"",
			"def query(p, l, r):",
			"    res = -INF",
			"    if l <= tr[p].l and tr[p].r <= r:",
			"        return tr[p].x",
			"    mid = tr[p].l + tr[p].r >> 1",
			"    if l <= mid:",
			"        res = max(res, query(ls(p), l, r))",
			"    if r > mid:",
			"        res = max(res, query(rs(p), l, r))",
			"    return res",
			""
		],
		"description": "线段树最大值"
	},
	"KMP": {
		"prefix": "KMP",
		"body": [
			"# p为模板串",
			"",
			"j = 0",
			"for i in range(2, n + 1):",
			"    while j and p[i] != p[j + 1]:",
			"        j = ne[j]",
			"    if p[i] == p[j + 1]:",
			"        j += 1",
			"    ne[i] = j",
			"",
			"j = 0",
			"for i in range(1, m + 1):",
			"    while j and s[i] != p[j + 1]:",
			"        j = ne[j]",
			"    if s[i] == p[j + 1]:",
			"        j += 1",
			"    if j == n:",
			"        print(i - n, end=\" \")",
			"        j = ne[j]"
		],
		"description": "KMP"
	},
	"lucas": {
		"prefix": "lucas",
		"body": [
			"def C(a, b): #直接求C",
			"    global p",
			"    i, j, res = a, 1, 1 #i对应的分子，j对应的分母",
			"    while j <= b:",
			"        res = res * i % p",
			"        res = res * pow(j, p - 2, p) % p",
			"        i -= 1",
			"        j += 1",
			"    return res",
			"",
			"",
			"def lucas(a, b):",
			"    if a < p and b < p:",
			"        return C(a, b)",
			"    return C(a % p, b % p) * lucas(a // p, b // p) % p"
		],
		"description": "lucas"
	},
	"单调队列": {
		"prefix": "Queue",
		"body": [
			"hh, tt = 0, -1",
			"    for i in range(n):",
			"        while hh <= tt and i - q[hh] + 1 > k:",
			"            hh += 1",
			"        while hh <= tt and nums[q[tt]] >= nums[i]:",
			"            tt -= 1",
			"        tt += 1",
			"        q[tt] = i"
		],
		"description": "单调队列"
	}
}